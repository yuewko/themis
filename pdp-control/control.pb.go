// Code generated by protoc-gen-go.
// source: control.proto
// DO NOT EDIT!

/*
Package control is a generated protocol buffer package.

It is generated from these files:
	control.proto

It has these top-level messages:
	Item
	Chunk
	Update
	Response
*/
package control

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Item_DataType int32

const (
	Item_POLICIES Item_DataType = 0
	Item_CONTENT  Item_DataType = 1
)

var Item_DataType_name = map[int32]string{
	0: "POLICIES",
	1: "CONTENT",
}
var Item_DataType_value = map[string]int32{
	"POLICIES": 0,
	"CONTENT":  1,
}

func (x Item_DataType) String() string {
	return proto.EnumName(Item_DataType_name, int32(x))
}
func (Item_DataType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type Response_Status int32

const (
	Response_ACK       Response_Status = 0
	Response_ERROR     Response_Status = 1
	Response_TAG_ERROR Response_Status = 2
)

var Response_Status_name = map[int32]string{
	0: "ACK",
	1: "ERROR",
	2: "TAG_ERROR",
}
var Response_Status_value = map[string]int32{
	"ACK":       0,
	"ERROR":     1,
	"TAG_ERROR": 2,
}

func (x Response_Status) String() string {
	return proto.EnumName(Response_Status_name, int32(x))
}
func (Response_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type Item struct {
	Type    Item_DataType `protobuf:"varint,1,opt,name=type,enum=control.Item_DataType" json:"type,omitempty"`
	FromTag string        `protobuf:"bytes,2,opt,name=fromTag" json:"fromTag,omitempty"`
	ToTag   string        `protobuf:"bytes,3,opt,name=toTag" json:"toTag,omitempty"`
	Id      string        `protobuf:"bytes,4,opt,name=id" json:"id,omitempty"`
}

func (m *Item) Reset()                    { *m = Item{} }
func (m *Item) String() string            { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()               {}
func (*Item) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Item) GetType() Item_DataType {
	if m != nil {
		return m.Type
	}
	return Item_POLICIES
}

func (m *Item) GetFromTag() string {
	if m != nil {
		return m.FromTag
	}
	return ""
}

func (m *Item) GetToTag() string {
	if m != nil {
		return m.ToTag
	}
	return ""
}

func (m *Item) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Chunk struct {
	Id   int32  `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Data string `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (m *Chunk) String() string            { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Chunk) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Chunk) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type Update struct {
	Id int32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *Update) Reset()                    { *m = Update{} }
func (m *Update) String() string            { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()               {}
func (*Update) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Update) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type Response struct {
	Status  Response_Status `protobuf:"varint,1,opt,name=status,enum=control.Response_Status" json:"status,omitempty"`
	Id      int32           `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	Details string          `protobuf:"bytes,3,opt,name=details" json:"details,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Response) GetStatus() Response_Status {
	if m != nil {
		return m.Status
	}
	return Response_ACK
}

func (m *Response) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Response) GetDetails() string {
	if m != nil {
		return m.Details
	}
	return ""
}

func init() {
	proto.RegisterType((*Item)(nil), "control.Item")
	proto.RegisterType((*Chunk)(nil), "control.Chunk")
	proto.RegisterType((*Update)(nil), "control.Update")
	proto.RegisterType((*Response)(nil), "control.Response")
	proto.RegisterEnum("control.Item_DataType", Item_DataType_name, Item_DataType_value)
	proto.RegisterEnum("control.Response_Status", Response_Status_name, Response_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for PDPControl service

type PDPControlClient interface {
	Request(ctx context.Context, in *Item, opts ...grpc.CallOption) (*Response, error)
	Upload(ctx context.Context, opts ...grpc.CallOption) (PDPControl_UploadClient, error)
	Apply(ctx context.Context, in *Update, opts ...grpc.CallOption) (*Response, error)
}

type pDPControlClient struct {
	cc *grpc.ClientConn
}

func NewPDPControlClient(cc *grpc.ClientConn) PDPControlClient {
	return &pDPControlClient{cc}
}

func (c *pDPControlClient) Request(ctx context.Context, in *Item, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/control.PDPControl/Request", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDPControlClient) Upload(ctx context.Context, opts ...grpc.CallOption) (PDPControl_UploadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_PDPControl_serviceDesc.Streams[0], c.cc, "/control.PDPControl/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &pDPControlUploadClient{stream}
	return x, nil
}

type PDPControl_UploadClient interface {
	Send(*Chunk) error
	CloseAndRecv() (*Response, error)
	grpc.ClientStream
}

type pDPControlUploadClient struct {
	grpc.ClientStream
}

func (x *pDPControlUploadClient) Send(m *Chunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *pDPControlUploadClient) CloseAndRecv() (*Response, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pDPControlClient) Apply(ctx context.Context, in *Update, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/control.PDPControl/Apply", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for PDPControl service

type PDPControlServer interface {
	Request(context.Context, *Item) (*Response, error)
	Upload(PDPControl_UploadServer) error
	Apply(context.Context, *Update) (*Response, error)
}

func RegisterPDPControlServer(s *grpc.Server, srv PDPControlServer) {
	s.RegisterService(&_PDPControl_serviceDesc, srv)
}

func _PDPControl_Request_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Item)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDPControlServer).Request(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/control.PDPControl/Request",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDPControlServer).Request(ctx, req.(*Item))
	}
	return interceptor(ctx, in, info, handler)
}

func _PDPControl_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PDPControlServer).Upload(&pDPControlUploadServer{stream})
}

type PDPControl_UploadServer interface {
	SendAndClose(*Response) error
	Recv() (*Chunk, error)
	grpc.ServerStream
}

type pDPControlUploadServer struct {
	grpc.ServerStream
}

func (x *pDPControlUploadServer) SendAndClose(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *pDPControlUploadServer) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _PDPControl_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Update)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDPControlServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/control.PDPControl/Apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDPControlServer).Apply(ctx, req.(*Update))
	}
	return interceptor(ctx, in, info, handler)
}

var _PDPControl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "control.PDPControl",
	HandlerType: (*PDPControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Request",
			Handler:    _PDPControl_Request_Handler,
		},
		{
			MethodName: "Apply",
			Handler:    _PDPControl_Apply_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _PDPControl_Upload_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "control.proto",
}

func init() { proto.RegisterFile("control.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 350 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x52, 0x5d, 0x4f, 0xea, 0x40,
	0x10, 0x65, 0x4b, 0x3f, 0x60, 0xee, 0x85, 0xdb, 0x3b, 0xb9, 0xb9, 0x69, 0x7c, 0x22, 0x4d, 0x4c,
	0x88, 0x84, 0x6a, 0xf0, 0x17, 0x90, 0x42, 0x0c, 0xd1, 0x00, 0x59, 0xea, 0xb3, 0x59, 0xed, 0xaa,
	0xc4, 0xc2, 0xae, 0x74, 0x79, 0xe0, 0x77, 0xf8, 0x64, 0xfc, 0xb3, 0xa6, 0xdb, 0x6d, 0x13, 0x95,
	0xb7, 0x3d, 0x73, 0xce, 0x99, 0x99, 0x33, 0x59, 0xe8, 0x3c, 0x88, 0xad, 0xda, 0x89, 0x2c, 0x92,
	0x3b, 0xa1, 0x04, 0x7a, 0x06, 0x86, 0xef, 0x04, 0xec, 0x99, 0xe2, 0x1b, 0x3c, 0x03, 0x5b, 0x1d,
	0x24, 0x0f, 0x48, 0x8f, 0xf4, 0xbb, 0xa3, 0xff, 0x51, 0xa5, 0x2f, 0xc8, 0x68, 0xc2, 0x14, 0x4b,
	0x0e, 0x92, 0x53, 0xad, 0xc1, 0x00, 0xbc, 0xc7, 0x9d, 0xd8, 0x24, 0xec, 0x29, 0xb0, 0x7a, 0xa4,
	0xdf, 0xa6, 0x15, 0xc4, 0x7f, 0xe0, 0x28, 0x51, 0xd4, 0x9b, 0xba, 0x5e, 0x02, 0xec, 0x82, 0xb5,
	0x4e, 0x03, 0x5b, 0x97, 0xac, 0x75, 0x1a, 0x9e, 0x42, 0xab, 0xea, 0x88, 0xbf, 0xa1, 0xb5, 0x5c,
	0xdc, 0xcc, 0xe2, 0xd9, 0x74, 0xe5, 0x37, 0xf0, 0x17, 0x78, 0xf1, 0x62, 0x9e, 0x4c, 0xe7, 0x89,
	0x4f, 0xc2, 0x01, 0x38, 0xf1, 0xf3, 0x7e, 0xfb, 0x62, 0xfc, 0xc5, 0x66, 0x4e, 0xe1, 0x47, 0x04,
	0x3b, 0x65, 0x8a, 0x99, 0xe1, 0xfa, 0x1d, 0x06, 0xe0, 0xde, 0xca, 0x94, 0x29, 0xfe, 0x5d, 0x1d,
	0xbe, 0x11, 0x68, 0x51, 0x9e, 0x4b, 0xb1, 0xcd, 0x39, 0x5e, 0x80, 0x9b, 0x2b, 0xa6, 0xf6, 0xb9,
	0x09, 0x1a, 0xd4, 0x41, 0x2b, 0x49, 0xb4, 0xd2, 0x3c, 0x35, 0x3a, 0xd3, 0xce, 0xaa, 0x87, 0x07,
	0xe0, 0xa5, 0x5c, 0xb1, 0x75, 0x96, 0x9b, 0x90, 0x15, 0x0c, 0x07, 0xe0, 0x96, 0x5e, 0xf4, 0xa0,
	0x39, 0x8e, 0xaf, 0xfd, 0x06, 0xb6, 0xc1, 0x99, 0x52, 0xba, 0xa0, 0x3e, 0xc1, 0x0e, 0xb4, 0x93,
	0xf1, 0xd5, 0x5d, 0x09, 0xad, 0xd1, 0x07, 0x01, 0x58, 0x4e, 0x96, 0x71, 0x39, 0x1d, 0x87, 0xe0,
	0x51, 0xfe, 0xba, 0xe7, 0xb9, 0xc2, 0xce, 0x97, 0xdb, 0x9f, 0xfc, 0xfd, 0xb1, 0x61, 0xd8, 0xc0,
	0xf3, 0x22, 0x6d, 0x26, 0x58, 0x8a, 0xdd, 0x9a, 0xd6, 0xb7, 0x3a, 0x2a, 0xef, 0x13, 0x1c, 0x82,
	0x33, 0x96, 0x32, 0x3b, 0xe0, 0x9f, 0x9a, 0x2f, 0xcf, 0x75, 0xd4, 0x70, 0xef, 0xea, 0x6f, 0x72,
	0xf9, 0x19, 0x00, 0x00, 0xff, 0xff, 0x22, 0xac, 0xb0, 0xb6, 0x37, 0x02, 0x00, 0x00,
}
